<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    



    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script>
        
        

    /*
    Each Vue instance goes through a series of initialization steps when it’s created - for example, 
    it needs to set up data observation, compile the template, mount the instance to the DOM, 
    and update the DOM when data changes.
    Along the way, it also runs functions called lifecycle hooks, 
    giving users the opportunity to add their own code at specific stages.

    For example, the created hook can be used to run code after an instance is created:
        new Vue({
            data: {
                a: 1
            },
            created: function () {
                //'this' points to the vm instance
                console.log('a is : ' + this.a)  //"a is : 1" 
            }
        })

    */

    /*
    There are also other hooks which will be called at different stages of the instance’s lifecycle, 
    such as mounted, updated, and destroyed. 
    All lifecycle hooks are called with their this context pointing to the Vue instance invoking it.
    */

    /*
    Don’t use arrow functions on an options property or callback, such as
    created: () => console.log(this.a) or vm.$watch('a', newValue => this.myMethod()). 
    Since an arrow function doesn’t have a this, this will be treated as any other variable 
    and lexically looked up through parent scopes until found, often resulting in errors such as
    Uncaught TypeError: Cannot read property of undefined or Uncaught TypeError: this.myMethod is not a function.
    */




    </script>



</body>
</html>